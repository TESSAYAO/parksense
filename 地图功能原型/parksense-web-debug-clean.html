<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>ParkSense - è°ƒè¯•ç‰ˆæœ¬</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ—ºï¸</text></svg>">
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * { margin:0; padding:0; box-sizing:border-box; }
    body { font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif; height:100vh; overflow:hidden; }
    #map { width:100%; height:100%; }
    .floating-btn {
      position:fixed; bottom:20px; right:20px; z-index:1000;
      width:56px; height:56px; border-radius:50%; background:#0ea5e9; color:#fff;
      border:none; cursor:pointer; box-shadow:0 4px 12px rgba(0,0,0,0.15);
      display:flex; align-items:center; justify-content:center; font-size:20px;
    }
    .floating-btn:hover { background:#0284c7; }
    .sidebar {
      position:fixed; top:0; right:-400px; width:400px; height:100vh; background:#fff;
      box-shadow:-2px 0 10px rgba(0,0,0,0.1); transition:right 0.3s ease; z-index:999;
      display:flex; flex-direction:column; overflow-y:auto;
    }
    .sidebar.open { right:0; }
    .sidebar header {
      background:#f8fafc;
      padding:16px; border-bottom:1px solid #e2e8f0; flex-shrink:0;
      display:flex; justify-content:space-between; align-items:center;
    }
    .title { font-weight:700; color:#155e75; font-size:18px; }
    .close-btn { background:none; border:none; font-size:24px; cursor:pointer; color:#64748b; }
    .content { padding:16px; flex:1; overflow-y:auto;
      display:flex; flex-direction:column; gap:8px;
    }
    .section-title { font-weight:600; font-size:14px; margin-bottom:6px; }
    .btn { padding:8px 12px; background:#f1f5f9; border:1px solid #cbd5e1;
      border-radius:6px; cursor:pointer; font-size:13px; flex-shrink:0;
    }
    .btn.primary { background:#0ea5e9; color:#fff; }
    .btn:hover { background:#e2e8f0; }
    .btn.primary:hover { background:#0284c7; }
    .layer-list { display:flex; flex-direction:column; gap:4px;
      max-height:200px; overflow-y:auto;
    }
    .layer-item {
      display:flex; justify-content:space-between; align-items:center; padding:6px 8px;
      background:#f8fafc; border:1px solid #e2e8f0; border-radius:4px;
      font-size:13px;
    }
    .layer-name { font-weight:500; color:#334155; }
    .layer-state { font-size:11px; padding:2px 6px; border-radius:3px; }
    .layer-state.ok { background:#dcfce7; color:#166534; }
    .layer-state.loading { background:#fef3c7; color:#92400e; }
    .layer-state.err { background:#fecaca; color:#991b1b; }
    .controls { display:flex; flex-direction:column; gap:8px;
      border-bottom:1px solid #f2f2f2;
    }
    .hint { font-size:12px; color:#334155; background:#f1f5f9; padding:8px; border-radius:6px; }
    .poi-controls { display:flex; flex-direction:column; gap:8px; }
    .control-row { display:flex; align-items:center; gap:8px; }
    .control-row label { font-size:13px; min-width:60px; }
    .control-row input[type="range"] { flex:1; }
    .control-row span { font-size:12px; color:#64748b; min-width:30px; }
    .poi-types { display:grid; grid-template-columns:1fr 1fr; gap:4px; max-height:200px; overflow-y:auto; }
    .poi-type { display:flex; align-items:center; gap:4px; font-size:12px; }
    .poi-buttons { display:flex; gap:4px; }
    .poi-buttons button { flex:1; padding:4px 8px; font-size:11px; }
    .analysis { font-size:12px; background:#f8fafc; padding:8px; border-radius:4px; margin-top:8px; }
    .pick-hint { position:fixed; top:20px; left:50%; transform:translateX(-50%); 
      background:#fbbf24; color:#92400e; padding:8px 16px; border-radius:6px; 
      font-size:14px; z-index:1000; display:none; }
    .layer-toggles { display:flex; flex-direction:column; gap:4px; }
    .layer-toggle { display:flex; align-items:center; gap:6px; font-size:13px; cursor:pointer; }
    .layer-toggle input[type="checkbox"] { margin:0; }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <button class="floating-btn" onclick="toggleSidebar()">âš™</button>
  
  <div class="sidebar" id="sidebar">
    <header>
      <div class="title">Layer Control</div>
      <button class="close-btn" onclick="toggleSidebar()">Ã—</button>
    </header>
    <div class="content">
      <div class="section-title">Data Layers <span id="layerStatus">0/6</span></div>
      <div class="layer-list" id="layerList"></div>
      
      <button class="btn primary" onclick="autoLoadAll()">Auto Load All</button>
      
      <div class="section-title">Layer Toggles</div>
      <div class="layer-toggles">
        <label class="layer-toggle">
          <input type="checkbox" data-layer="boundary" checked> Park Boundary
        </label>
        <label class="layer-toggle">
          <input type="checkbox" data-layer="trails" checked> Trail Network
        </label>
        <label class="layer-toggle">
          <input type="checkbox" data-layer="vegetation" checked> Vegetation Areas
        </label>
        <label class="layer-toggle">
          <input type="checkbox" data-layer="water" checked> Water Features
        </label>
        <label class="layer-toggle">
          <input type="checkbox" data-layer="facilities" checked> Park Facilities
        </label>
        <label class="layer-toggle">
          <input type="checkbox" data-layer="poi" checked> Points of Interest
        </label>
      </div>
      
      <div class="section-title">POI Controls</div>
      <div class="poi-controls">
        <div class="control-row">
          <label>Size:</label>
          <input type="range" id="poiSize" min="2" max="10" value="4">
          <span id="poiSizeValue">4</span>
        </div>
        <div class="control-row">
          <label>Opacity:</label>
          <input type="range" id="poiOpacity" min="0.1" max="1" step="0.1" value="0.8">
          <span id="poiOpacityValue">0.8</span>
        </div>
        <div class="control-row">
          <label>Limit:</label>
          <input type="range" id="poiLimit" min="50" max="1000" step="50" value="1000">
          <span id="poiLimitValue">1000</span>
        </div>
        <div class="control-row">
          <label>Geo Filter:</label>
          <select id="poiFilter">
            <option value="none">No Filter</option>
            <option value="ultra-strict">Ultra Strict</option>
            <option value="strict">Strict</option>
            <option value="moderate">Moderate</option>
            <option value="loose" selected>Loose</option>
          </select>
        </div>
        
        <div class="section-title">POI Type Selection</div>
        <div class="poi-buttons">
          <button class="btn" id="selectAllPoi">Select All</button>
          <button class="btn" id="selectNonePoi">Select None</button>
          <button class="btn" id="selectEssentialPoi">Essential</button>
        </div>
        
        <div class="poi-types">
          <label class="poi-type"><input type="checkbox" id="poi-toilets" checked> Toilets</label>
          <label class="poi-type"><input type="checkbox" id="poi-food" checked> Food & Drink</label>
          <label class="poi-type"><input type="checkbox" id="poi-entrance" checked> Entrance</label>
          <label class="poi-type"><input type="checkbox" id="poi-information" checked> Information</label>
          <label class="poi-type"><input type="checkbox" id="poi-playground"> Playground</label>
          <label class="poi-type"><input type="checkbox" id="poi-bench"> Benches</label>
          <label class="poi-type"><input type="checkbox" id="poi-water" checked> Water Fountain</label>
          <label class="poi-type"><input type="checkbox" id="poi-parking"> Parking</label>
          <label class="poi-type"><input type="checkbox" id="poi-shop"> Shop</label>
          <label class="poi-type"><input type="checkbox" id="poi-garden"> Garden</label>
          <label class="poi-type"><input type="checkbox" id="poi-trees"> Trees</label>
          <label class="poi-type"><input type="checkbox" id="poi-wildlife" checked> Wildlife</label>
          <label class="poi-type"><input type="checkbox" id="poi-water-feature" checked> Water Features</label>
          <label class="poi-type"><input type="checkbox" id="poi-memorial" checked> Memorial</label>
          <label class="poi-type"><input type="checkbox" id="poi-bridge"> Bridge</label>
          <label class="poi-type"><input type="checkbox" id="poi-viewpoint"> Viewpoint</label>
          <label class="poi-type"><input type="checkbox" id="poi-art"> Art Installation</label>
          <label class="poi-type"><input type="checkbox" id="poi-monument"> Monument</label>
          <label class="poi-type"><input type="checkbox" id="poi-other"> Other</label>
        </div>
        
        <button class="btn primary" id="reloadPoi">Reload POI</button>
        <button class="btn" id="analyzePoi">Analyze POI Data</button>
        <div class="analysis" id="poiAnalysis">Click analyze button to view POI statistics</div>
      </div>
      
      <div class="section-title">Route Planning</div>
      <div class="controls">
        <button class="btn" id="pickStart">Select Start</button>
        <button class="btn" id="pickEnd">Select End</button>
        <button class="btn primary" id="plan" disabled>Plan Route</button>
        <button class="btn" id="clear">Clear</button>
        <div id="statDistance">Total Distance: â€”</div>
        <div id="statTime">Estimated Time: â€”</div>
        <div id="weather">Weather: Cloudy 16Â°C</div>
      </div>
    </div>
  </div>
  
  <div class="pick-hint" id="pickHint"></div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    // åŸºç¡€é…ç½®å’Œå˜é‡
    const AUTO_ENABLE = true;
    const LONDON_BOUNDS = { minLng: -0.5, maxLng: 0.5, minLat: 51.2, maxLat: 51.8 };
    
    const LAYER_FILES = {
      boundary: '../local-nav/local-nav/park-data/park-data/park_boundary.geojson',
      trails: '../local-nav/local-nav/park-data/park-data/trails.geojson',
      vegetation: '../local-nav/local-nav/park-data/park-data/vegetation.geojson',
      water: '../local-nav/local-nav/park-data/park-data/water.geojson',
      facilities: '../local-nav/local-nav/park-data/park-data/facilities_toilet_drink_bench.geojson',
      poi: '../local-nav/local-nav/park-data/park-data/poi_all.geojson'
    };

    // åœ°å›¾åˆå§‹åŒ–
    const map = L.map('map').setView([51.5045, -0.1300], 16);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors'
    }).addTo(map);

    const layers = {};
    let pickMode = null;
    let startLatLng = null, endLatLng = null;
    let startMarker = null, endMarker = null, routeLine = null;

    // åŸºç¡€åŠŸèƒ½å‡½æ•°
    function toggleSidebar() {
      document.getElementById('sidebar').classList.toggle('open');
    }

    function isInLondon(lng, lat) {
      return lng >= LONDON_BOUNDS.minLng && lng <= LONDON_BOUNDS.maxLng && 
             lat >= LONDON_BOUNDS.minLat && lat <= LONDON_BOUNDS.maxLat;
    }

    function filterGeoJSONFeatures(geojson) {
      if (!geojson || !geojson.features) return geojson;
      
      const filtered = { ...geojson, features: [] };
      geojson.features.forEach(feature => {
        let coords = null;
        if (feature.geometry.type === 'Point') {
          coords = feature.geometry.coordinates;
        } else if (feature.geometry.type === 'Polygon' && feature.geometry.coordinates[0]) {
          coords = feature.geometry.coordinates[0][0];
        } else if (feature.geometry.type === 'LineString' && feature.geometry.coordinates[0]) {
          coords = feature.geometry.coordinates[0];
        }
        
        if (coords && isInLondon(coords[0], coords[1])) {
          filtered.features.push(feature);
        }
      });
      
      return filtered;
    }

    function getLayerStyle(key) {
      const styles = {
        boundary: { color: '#dc2626', weight: 3, fillOpacity: 0.1 },
        trails: { color: '#059669', weight: 2, opacity: 0.8 },
        vegetation: { color: '#16a34a', fillOpacity: 0.3, weight: 1 },
        water: { color: '#0ea5e9', fillOpacity: 0.6, weight: 1 },
        facilities: { color: '#7c3aed', fillOpacity: 0.7, radius: 6 }
      };
      return styles[key] || { color: '#64748b', weight: 2 };
    }

    function createLayerFromGeoJSON(key, geojson) {
      const style = getLayerStyle(key);
      
      return L.geoJSON(geojson, {
        style: feature => style,
        pointToLayer: (feature, latlng) => {
          if (key === 'poi') {
            return L.circleMarker(latlng, {
              radius: 4, fillColor: '#f59e0b', color: '#fff', weight: 1,
              fillOpacity: 0.8, opacity: 1
            });
          }
          return L.circleMarker(latlng, { ...style, radius: style.radius || 5 });
        },
        onEachFeature: (feature, layer) => {
          const props = feature.properties || {};
          const name = props.name || props.Name || 'Unnamed';
          
          // åªæœ‰åœ¨éé€‰æ‹©æ¨¡å¼ä¸‹æ‰æ˜¾ç¤ºå¼¹å‡ºçª—å£
          layer.on('click', (e) => {
            if (pickMode) {
              // é˜»æ­¢å¼¹å‡ºçª—å£ï¼Œè®©åœ°å›¾ç‚¹å‡»äº‹ä»¶å¤„ç†
              e.originalEvent.stopPropagation();
              return;
            }
            
            // æ­£å¸¸æ˜¾ç¤ºå¼¹å‡ºçª—å£
            if (key === 'poi') {
              const amenity = props.amenity || '';
              const tourism = props.tourism || '';
              layer.bindPopup(`<strong>${name}</strong><br>Type: ${amenity || tourism || 'Other'}`).openPopup();
            } else {
              layer.bindPopup(`<strong>${name}</strong>`).openPopup();
            }
          });
        }
      });
    }

    function updateLayerUI(key, success, message = '') {
      const el = document.querySelector(`[data-layer="${key}"] .layer-state`);
      if (!el) return;
      
      if (success) {
        el.className = 'layer-state ok';
        el.textContent = 'Loaded';
      } else {
        el.className = 'layer-state err';
        el.textContent = 'Load failed' + (message ? (' Â· ' + message) : '');
      }
      
      updateLayerStatus();
    }

    function updateLayerStatus() {
      const total = Object.keys(LAYER_FILES).length;
      const loaded = document.querySelectorAll('.layer-state.ok').length;
      document.getElementById('layerStatus').textContent = `${loaded}/${total}`;
    }

    async function fetchJSON(url) {
      const res = await fetch(url);
      if (!res.ok) throw new Error(`HTTP ${res.status}`);
      return res.json();
    }

    async function loadLayer(key, filename) {
      updateLayerUI(key, false, 'Loading...');
      
      try {
        let data = await fetchJSON(filename);
        
        if (key !== 'poi') {
          data = filterGeoJSONFeatures(data);
        }
        
        const layer = createLayerFromGeoJSON(key, data);
        
        if (layers[key]) {
          map.removeLayer(layers[key]);
        }
        
        layers[key] = layer;
        layer.addTo(map);
        
        if (key === 'boundary') {
          try {
            map.fitBounds(layer.getBounds(), { padding: [20, 20] });
          } catch (e) {
            console.warn(`[BOUNDARY] è°ƒæ•´è§†å›¾å¤±è´¥:`, e);
          }
        }
        
        if (key === 'trails') {
          window.trailFeatures = data.features;
          trailGraph = buildTrailGraph(data.features);
          updatePlanButton();
        }
        
        updateLayerUI(key, true);
      } catch (e) {
        console.error(`[${key.toUpperCase()}] åŠ è½½å¤±è´¥:`, e);
        updateLayerUI(key, false, e.message);
      }
    }

    async function autoLoadAll() {
      await Promise.all(Object.entries(LAYER_FILES).map(([k, f]) => loadLayer(k, f)));
      
      // è‡ªåŠ¨åŠ è½½POIæ•°æ®ï¼Œåº”ç”¨é»˜è®¤è¿‡æ»¤è®¾ç½®
      setTimeout(() => {
        const reloadPoiBtn = document.getElementById('reloadPoi');
        if (reloadPoiBtn) {
          reloadPoiBtn.click();
        }
      }, 1000);
    }

    function setupStyleControls() {
      // åˆ›å»ºå›¾å±‚åˆ—è¡¨UI
      const layerList = document.getElementById('layerList');
      Object.keys(LAYER_FILES).forEach(key => {
        const item = document.createElement('div');
        item.className = 'layer-item';
        item.setAttribute('data-layer', key);
        item.innerHTML = `
          <span class="layer-name">${key}</span>
          <span class="layer-state loading">Waiting to load</span>
        `;
        layerList.appendChild(item);
      });
    }

    // å…¨å±€POIç±»å‹è¿‡æ»¤å‡½æ•°
    function filterBySelectedTypes(features) {
      const selectedTypes = {
        toilets: document.getElementById('poi-toilets').checked,
        food: document.getElementById('poi-food').checked,
        entrance: document.getElementById('poi-entrance').checked,
        information: document.getElementById('poi-information').checked,
        playground: document.getElementById('poi-playground').checked,
        bench: document.getElementById('poi-bench').checked,
        water: document.getElementById('poi-water').checked,
        parking: document.getElementById('poi-parking').checked,
        shop: document.getElementById('poi-shop').checked,
        garden: document.getElementById('poi-garden').checked,
        trees: document.getElementById('poi-trees').checked,
        wildlife: document.getElementById('poi-wildlife').checked,
        waterFeature: document.getElementById('poi-water-feature').checked,
        memorial: document.getElementById('poi-memorial').checked,
        bridge: document.getElementById('poi-bridge').checked,
        viewpoint: document.getElementById('poi-viewpoint').checked,
        art: document.getElementById('poi-art').checked,
        monument: document.getElementById('poi-monument').checked,
        other: document.getElementById('poi-other').checked
      };

      return features.filter(feature => {
        const props = feature.properties || {};
        const name = (props.name || '').toLowerCase();
        const amenity = (props.amenity || '').toLowerCase();
        const tourism = (props.tourism || '').toLowerCase();
        
        // æ£€æŸ¥å„ç§POIç±»å‹
        if (selectedTypes.toilets && (amenity.includes('toilet') || name.includes('toilet'))) return true;
        if (selectedTypes.food && (amenity.includes('cafe') || amenity.includes('restaurant') || name.includes('cafe'))) return true;
        if (selectedTypes.entrance && (name.includes('entrance') || name.includes('gate'))) return true;
        if (selectedTypes.information && (tourism.includes('information') || name.includes('information'))) return true;
        if (selectedTypes.playground && (amenity.includes('playground') || name.includes('playground'))) return true;
        if (selectedTypes.bench && (amenity.includes('bench') || name.includes('bench'))) return true;
        if (selectedTypes.water && (amenity.includes('drinking_water') || name.includes('water'))) return true;
        if (selectedTypes.parking && (amenity.includes('parking') || name.includes('parking'))) return true;
        if (selectedTypes.shop && (props.shop || amenity.includes('shop'))) return true;
        if (selectedTypes.garden && (props.leisure === 'garden' || name.includes('garden'))) return true;
        if (selectedTypes.trees && (props.natural === 'tree' || name.includes('tree'))) return true;
        if (selectedTypes.wildlife && (name.includes('duck') || name.includes('bird') || name.includes('animal'))) return true;
        if (selectedTypes.waterFeature && (name.includes('lake') || name.includes('pond') || props.natural === 'water')) return true;
        if (selectedTypes.memorial && (props.historic === 'memorial' || name.includes('memorial'))) return true;
        if (selectedTypes.bridge && (props.man_made === 'bridge' || name.includes('bridge'))) return true;
        if (selectedTypes.viewpoint && (tourism.includes('viewpoint') || name.includes('view'))) return true;
        if (selectedTypes.art && (tourism.includes('artwork') || name.includes('art'))) return true;
        if (selectedTypes.monument && (tourism.includes('monument') || name.includes('statue'))) return true;
        if (selectedTypes.other && !amenity && !tourism && !props.natural) return true;
        
        return false;
      });
    }

    function setupPoiControls() {
      const poiSize = document.getElementById('poiSize');
      const poiSizeValue = document.getElementById('poiSizeValue');
      const poiOpacity = document.getElementById('poiOpacity');
      const poiOpacityValue = document.getElementById('poiOpacityValue');
      const poiLimit = document.getElementById('poiLimit');
      const poiLimitValue = document.getElementById('poiLimitValue');
      const poiFilter = document.getElementById('poiFilter');
      const reloadPoi = document.getElementById('reloadPoi');
      const analyzePoi = document.getElementById('analyzePoi');
      const poiAnalysis = document.getElementById('poiAnalysis');
      const selectAllPoi = document.getElementById('selectAllPoi');
      const selectNonePoi = document.getElementById('selectNonePoi');
      const selectEssentialPoi = document.getElementById('selectEssentialPoi');

      // æ›´æ–°æ˜¾ç¤ºå€¼
      poiSize.oninput = () => {
        poiSizeValue.textContent = poiSize.value;
        updatePoiStyle();
      };
      poiOpacity.oninput = () => {
        poiOpacityValue.textContent = poiOpacity.value;
        updatePoiStyle();
      };
      poiLimit.oninput = () => {
        poiLimitValue.textContent = poiLimit.value;
      };

      // POIç±»å‹é€‰æ‹©å¿«æ·æŒ‰é’®
      selectAllPoi.onclick = () => {
        document.querySelectorAll('[id^="poi-"]').forEach(cb => cb.checked = true);
      };
      
      selectNonePoi.onclick = () => {
        document.querySelectorAll('[id^="poi-"]').forEach(cb => cb.checked = false);
      };
      
      selectEssentialPoi.onclick = () => {
        document.querySelectorAll('[id^="poi-"]').forEach(cb => cb.checked = false);
        document.getElementById('poi-toilets').checked = true;
        document.getElementById('poi-entrance').checked = true;
        document.getElementById('poi-information').checked = true;
        document.getElementById('poi-water').checked = true;
        document.getElementById('poi-wildlife').checked = true;
        document.getElementById('poi-water-feature').checked = true;
        document.getElementById('poi-memorial').checked = true;
      };

      // POIæ ·å¼æ›´æ–°
      function updatePoiStyle() {
        if (layers.poi) {
          const size = parseInt(poiSize.value);
          const opacity = parseFloat(poiOpacity.value);
          
          layers.poi.eachLayer(layer => {
            if (layer.setRadius && typeof layer.setRadius === 'function') {
              layer.setRadius(size);
            }
            if (layer.setStyle && typeof layer.setStyle === 'function') {
              layer.setStyle({ fillOpacity: opacity, opacity: opacity });
            }
          });
        }
      }

      function getFilterBounds(filterType) {
        switch (filterType) {
          case 'ultra-strict': return { minLng: -0.133, maxLng: -0.127, minLat: 51.503, maxLat: 51.507 };
          case 'strict': return { minLng: -0.138, maxLng: -0.122, minLat: 51.501, maxLat: 51.509 };
          case 'moderate': return { minLng: -0.16, maxLng: -0.10, minLat: 51.495, maxLat: 51.515 };
          case 'loose': return { minLng: -0.3, maxLng: 0.1, minLat: 51.45, maxLat: 51.55 };
          default: return null;
        }
      }

      function limitFeatures(features, maxCount) {
        if (features.length <= maxCount) return features;
        
        const sorted = features.sort((a, b) => {
          const aProps = a.properties || {};
          const bProps = b.properties || {};
          const aName = (aProps.name || '').toLowerCase();
          const bName = (bProps.name || '').toLowerCase();
          const aAmenity = (aProps.amenity || '').toLowerCase();
          const bAmenity = (bProps.amenity || '').toLowerCase();
          
          if (aAmenity.includes('toilet') && !bAmenity.includes('toilet')) return -1;
          if (!aAmenity.includes('toilet') && bAmenity.includes('toilet')) return 1;
          
          if (aName.includes('entrance') && !bName.includes('entrance')) return -1;
          if (!aName.includes('entrance') && bName.includes('entrance')) return 1;
          
          return 0;
        });
        
        return sorted.slice(0, maxCount);
      }

      function getFeatureCoords(feature) {
        if (feature.geometry.type === 'Point') {
          return feature.geometry.coordinates;
        }
        return null;
      }

      function isInBounds(coords, bounds) {
        const [lng, lat] = coords;
        return lng >= bounds.minLng && lng <= bounds.maxLng && 
               lat >= bounds.minLat && lat <= bounds.maxLat;
      }

      // é‡æ–°åŠ è½½POI
      reloadPoi.onclick = async () => {
        const filterType = poiFilter.value;
        const maxCount = parseInt(poiLimit.value);
        
        console.log(`[POI] é‡æ–°åŠ è½½ï¼Œåœ°ç†è¿‡æ»¤: ${filterType}, æœ€å¤§æ•°é‡: ${maxCount}`);
        
        try {
          const response = await fetch('../local-nav/local-nav/park-data/park-data/poi_all.geojson');
          const originalData = await response.json();
          
          let features = originalData.features;
          let geoFilteredCount = features.length;
          
          // 1. åœ°ç†ä½ç½®è¿‡æ»¤
          if (filterType !== 'none') {
            const bounds = getFilterBounds(filterType);
            features = features.filter(feature => {
              const coords = getFeatureCoords(feature);
              return coords && isInBounds(coords, bounds);
            });
            geoFilteredCount = features.length;
          }
          
          // 2. ç±»å‹è¿‡æ»¤
          const typeFilteredFeatures = filterBySelectedTypes(features);
          
          // 3. æ•°é‡é™åˆ¶
          const finalFeatures = limitFeatures(typeFilteredFeatures, maxCount);
          
          // 4. æ›´æ–°å›¾å±‚
          const finalData = { ...originalData, features: finalFeatures };
          
          if (layers.poi) {
            map.removeLayer(layers.poi);
          }
          
          layers.poi = createLayerFromGeoJSON('poi', finalData);
          layers.poi.addTo(map);
          
          poiAnalysis.innerHTML = `
            <strong>POIé‡æ–°åŠ è½½å®Œæˆ</strong><br>
            åŸå§‹æ•°æ®: ${originalData.features.length}ä¸ª<br>
            åœ°ç†è¿‡æ»¤å: ${geoFilteredCount}ä¸ª<br>
            ç±»å‹è¿‡æ»¤å: ${typeFilteredFeatures.length}ä¸ª<br>
            æœ€ç»ˆæ˜¾ç¤º: ${finalFeatures.length}ä¸ª
          `;
          
          updatePoiStyle();
          
        } catch (e) {
          console.error('[POI] é‡æ–°åŠ è½½å¤±è´¥:', e);
          poiAnalysis.innerHTML = `<span style="color: red;">é‡æ–°åŠ è½½å¤±è´¥: ${e.message}</span>`;
        }
      };

      // åˆ†æPOIæ•°æ®
      analyzePoi.onclick = async () => {
        try {
          const response = await fetch('../local-nav/local-nav/park-data/park-data/poi_all.geojson');
          const data = await response.json();
          const features = data.features;
          
          let minLng = Infinity, maxLng = -Infinity;
          let minLat = Infinity, maxLat = -Infinity;
          let validCount = 0;
          
          features.forEach(feature => {
            if (feature.geometry.type === 'Point') {
              const [lng, lat] = feature.geometry.coordinates;
              if (lng && lat) {
                minLng = Math.min(minLng, lng);
                maxLng = Math.max(maxLng, lng);
                minLat = Math.min(minLat, lat);
                maxLat = Math.max(maxLat, lat);
                validCount++;
              }
            }
          });
          
          poiAnalysis.innerHTML = `
            <strong>POIæ•°æ®åˆ†æ</strong><br>
            æ€»ç‰¹å¾æ•°: ${features.length}<br>
            æœ‰æ•ˆåæ ‡: ${validCount}<br>
            ç»åº¦èŒƒå›´: ${minLng.toFixed(6)} ~ ${maxLng.toFixed(6)}<br>
            çº¬åº¦èŒƒå›´: ${minLat.toFixed(6)} ~ ${maxLat.toFixed(6)}
          `;
        } catch (e) {
          poiAnalysis.innerHTML = `<span style="color: red;">åˆ†æå¤±è´¥: ${e.message}</span>`;
        }
      };
    }

    // è·¯å¾„è§„åˆ’åŠŸèƒ½ - å‚è€ƒparksense-bottom.html
    let trailGraph = null;

    function buildTrailGraph(trailFeatures) {
      const graph = { nodes: new Map(), edges: [] };
      let nodeId = 0;
      
      // ä»æ­¥é“ç‰¹å¾æ„å»ºèŠ‚ç‚¹å’Œè¾¹
      trailFeatures.forEach(feature => {
        if (feature.geometry.type === 'LineString') {
          const coords = feature.geometry.coordinates;
          const nodes = [];
          
          // ä¸ºæ¯ä¸ªåæ ‡ç‚¹åˆ›å»ºèŠ‚ç‚¹
          coords.forEach(coord => {
            const latlng = [coord[1], coord[0]]; // GeoJSONæ˜¯[lng,lat]ï¼ŒLeafletæ˜¯[lat,lng]
            const id = `node_${nodeId++}`;
            
            const node = {
              id: id,
              latlng: latlng,
              adj: new Map()
            };
            
            graph.nodes.set(id, node);
            nodes.push(node);
          });
          
          // è¿æ¥ç›¸é‚»èŠ‚ç‚¹
          for (let i = 0; i < nodes.length - 1; i++) {
            const nodeA = nodes[i];
            const nodeB = nodes[i + 1];
            const distance = haversine(nodeA.latlng, nodeB.latlng);
            
            nodeA.adj.set(nodeB.id, distance);
            nodeB.adj.set(nodeA.id, distance);
            
            graph.edges.push({
              from: nodeA.id,
              to: nodeB.id,
              weight: distance
            });
          }
        }
      });
      
      console.log(`æ„å»ºæ­¥é“å›¾: ${graph.nodes.size} ä¸ªèŠ‚ç‚¹, ${graph.edges.length} æ¡è¾¹`);
      return graph;
    }

    function haversine(p1, p2) {
      const R = 6371000;
      const lat1 = p1[0] * Math.PI / 180, lng1 = p1[1] * Math.PI / 180;
      const lat2 = p2[0] * Math.PI / 180, lng2 = p2[1] * Math.PI / 180;
      const dlat = lat2 - lat1, dlng = lng2 - lng1;
      const A = Math.sin(dlat/2)**2 + Math.cos(lat1) * Math.cos(lat2) * Math.sin(dlng/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(A), Math.sqrt(1-A));
    }

    function buildTrailGraph(features) {
      const nodes = new Map(), edges = [];
      let nodeId = 0;
      
      features.forEach(feature => {
        if (feature.geometry.type === 'LineString') {
          const coords = feature.geometry.coordinates;
          let prevId = null;
          
          coords.forEach(coord => {
            const [lng, lat] = coord;
            const key = `${lat.toFixed(6)},${lng.toFixed(6)}`;
            
            if (!nodes.has(key)) {
              const id = nodeId++;
              nodes.set(key, { id, latlng: [lat, lng], adj: new Map() });
            }
            
            const currentId = nodes.get(key).id;
            if (prevId !== null) {
              const dist = haversine(nodes.get(Array.from(nodes.keys())[prevId]).latlng, [lat, lng]);
              nodes.get(Array.from(nodes.keys())[prevId]).adj.set(currentId, dist);
              nodes.get(key).adj.set(prevId, dist);
            }
            prevId = currentId;
          });
        }
      });
      
      return { nodes, edges };
    }

    function nearestNode(latlng) {
      if (!trailGraph) return null;
      let nearest = null, minDist = Infinity;
      
      for (const node of trailGraph.nodes.values()) {
        const dist = haversine(latlng, node.latlng);
        if (dist < minDist) {
          minDist = dist;
          nearest = node;
        }
      }
      
      return minDist < 100 ? nearest : null; // 100ç±³å†…
    }

    function dijkstra(startId, endId) {
      if (!trailGraph) return null;
      
      const dist = new Map(), prev = new Map(), visited = new Set();
      const pq = [];
      
      for (const node of trailGraph.nodes.values()) {
        dist.set(node.id, node.id === startId ? 0 : Infinity);
        pq.push(node.id);
      }
      
      while (pq.length > 0) {
        pq.sort((a, b) => dist.get(a) - dist.get(b));
        const u = pq.shift();
        
        if (visited.has(u)) continue;
        visited.add(u);
        
        if (u === endId) break;
        
        const uNode = Array.from(trailGraph.nodes.values()).find(n => n.id === u);
        if (!uNode) continue;
        
        for (const [v, weight] of uNode.adj) {
          if (visited.has(v)) continue;
          const alt = dist.get(u) + weight;
          if (alt < dist.get(v)) {
            dist.set(v, alt);
            prev.set(v, u);
          }
        }
      }
      
      // é‡å»ºè·¯å¾„
      const path = [];
      let current = endId;
      while (current !== undefined) {
        const node = Array.from(trailGraph.nodes.values()).find(n => n.id === current);
        if (node) path.unshift(node.latlng);
        current = prev.get(current);
      }
      
      return path.length > 1 ? path : null;
    }

    function findNearestNode(latlng) {
      if (!trailGraph || trailGraph.nodes.size === 0) return null;
      
      let nearest = null;
      let minDist = Infinity;
      
      for (const node of trailGraph.nodes.values()) {
        const dist = haversine(latlng, node.latlng);
        if (dist < minDist) {
          minDist = dist;
          nearest = node;
        }
      }
      
      return nearest;
    }

    function routeDistance(points) {
      let s = 0;
      for (let i = 0; i < points.length - 1; i++) {
        s += haversine(points[i], points[i + 1]);
      }
      return s;
    }

    function setPickMode(mode) {
      pickMode = mode;
      const pickHint = document.getElementById('pickHint');
      
      // æ§åˆ¶POIå¼¹çª—çš„å¯ç”¨/ç¦ç”¨
      if (layers.poi) {
        layers.poi.eachLayer(layer => {
          if (mode === 'start' || mode === 'end') {
            // ç¦ç”¨å¼¹çª—
            layer.unbindPopup();
            layer.closePopup();
          } else {
            // é‡æ–°å¯ç”¨å¼¹çª—
            if (layer.feature && layer.feature.properties) {
              const props = layer.feature.properties;
              const name = props.name || 'æœªçŸ¥åœ°ç‚¹';
              const amenity = props.amenity || '';
              const tourism = props.tourism || '';
              let popupContent = `<strong>${name}</strong>`;
              if (amenity) popupContent += `<br>ç±»å‹: ${amenity}`;
              if (tourism) popupContent += `<br>æ—…æ¸¸: ${tourism}`;
              layer.bindPopup(popupContent);
            }
          }
        });
      }
      
      if (mode === 'start') {
        pickHint.style.display = 'block';
        pickHint.textContent = 'Tip: Click on the map to select start point (POI popups disabled)';
      } else if (mode === 'end') {
        pickHint.style.display = 'block';
        pickHint.textContent = 'Tip: Click on the map to select end point (POI popups disabled)';
      } else {
        pickHint.style.display = 'none';
        pickHint.textContent = '';
      }
      updatePlanButton();
    }
    
    function updatePlanButton() {
      const planBtn = document.getElementById('plan');
      planBtn.disabled = !(startLatLng && endLatLng);
    }

    function clearAll() {
      if (routeLine) { map.removeLayer(routeLine); routeLine = null; }
      if (startMarker) { map.removeLayer(startMarker); startMarker = null; }
      if (endMarker) { map.removeLayer(endMarker); endMarker = null; }
      startLatLng = null; endLatLng = null;
      document.getElementById('statDistance').textContent = 'Total Distance: â€”';
      document.getElementById('statTime').textContent = 'Estimated Time: â€”';
      setPickMode(null);
    }

    function planRoute() {
      if (!(startLatLng && endLatLng)) return;
      if (routeLine) map.removeLayer(routeLine);
      
      try {
        // å¦‚æœæœ‰æ­¥é“ç½‘ç»œå›¾ï¼Œä½¿ç”¨Dijkstraç®—æ³•
        if (trailGraph && trailGraph.nodes.size > 0) {
          const startNode = findNearestNode(startLatLng);
          const endNode = findNearestNode(endLatLng);
          
          if (startNode && endNode) {
            const routePath = dijkstra(startNode.id, endNode.id);
            if (routePath && routePath.length > 1) {
              routeLine = L.polyline(routePath, {color:'#e11d48', weight:4}).addTo(map);
              const dist = routeDistance(routePath);
              document.getElementById('statDistance').textContent = `Total Distance: ${Math.round(dist)} m`;
              document.getElementById('statTime').textContent = `Estimated Time: ${Math.max(1, Math.round(dist/80))} min`;
              return;
            }
          }
        }
        
        // å›é€€åˆ°ç›´çº¿è·¯å¾„
        routeLine = L.polyline([startLatLng, endLatLng], {color:'#e11d48', weight:4, dashArray:'5,5'}).addTo(map);
        const dist = map.distance(startLatLng, endLatLng);
        document.getElementById('statDistance').textContent = `Total Distance: ${Math.round(dist)} m (straight line)`;
        document.getElementById('statTime').textContent = `Estimated Time: ${Math.max(1, Math.round(dist/80))} min`;
        
      } catch (error) {
        console.error('Route planning failed:', error);
        // ä½¿ç”¨ç›´çº¿ä½œä¸ºå¤‡ç”¨æ–¹æ¡ˆ
        routeLine = L.polyline([startLatLng, endLatLng], {color:'#e11d48', weight:4, dashArray:'5,5'}).addTo(map);
        const dist = map.distance(startLatLng, endLatLng);
        document.getElementById('statDistance').textContent = `Total Distance: ${Math.round(dist)} m (straight line)`;
        document.getElementById('statTime').textContent = `Estimated Time: ${Math.max(1, Math.round(dist/80))} min`;
      }
    }

    // äº‹ä»¶ç›‘å¬å™¨
    document.getElementById('pickStart').onclick = () => setPickMode('start');
    document.getElementById('pickEnd').onclick = () => setPickMode('end');
    document.getElementById('clear').onclick = clearAll;
    document.getElementById('plan').onclick = planRoute;

    map.on('click', (e) => {
      if (!pickMode) return;
      if (pickMode === 'start') {
        if (startMarker) map.removeLayer(startMarker);
        startLatLng = [e.latlng.lat, e.latlng.lng];
        startMarker = L.circleMarker(startLatLng, {radius:8, color:'#fff', weight:2, fillColor:'#22c55e', fillOpacity:1}).addTo(map).bindPopup('Start');
      } else if (pickMode === 'end') {
        if (endMarker) map.removeLayer(endMarker);
        endLatLng = [e.latlng.lat, e.latlng.lng];
        endMarker = L.circleMarker(endLatLng, {radius:8, color:'#fff', weight:2, fillColor:'#ef4444', fillOpacity:1}).addTo(map).bindPopup('End');
      }
      setPickMode(null);
      updatePlanButton();
    });

    // å¤©æ°”ä¿¡æ¯ - å‚è€ƒparksense-bottom.html
    (async function() {
      try {
        const r = await fetch("https://api.openweathermap.org/data/2.5/weather?lat=51.5029&lon=-0.1342&units=metric&lang=en&appid=b3c7d2985be74417378ca6517f19c700");
        const j = await r.json();
        const t = Math.round(j.main?.temp ?? 0);
        const d = j.weather?.[0]?.description || '';
        document.getElementById('weather').textContent = `Weather: ${d}, ${t}Â°C`;
      } catch(e) {
        document.getElementById('weather').textContent = 'Weather: Load failed (does not affect navigation)';
      }
    })();

    // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨åŠ è½½æ•°æ®
    // å›¾å±‚å¼€å…³åŠŸèƒ½
    function setupLayerToggles() {
      document.querySelectorAll('[data-layer]').forEach(checkbox => {
        checkbox.addEventListener('change', () => {
          const layerKey = checkbox.getAttribute('data-layer');
          const layer = layers[layerKey];
          
          if (!layer) return;
          
          if (checkbox.checked) {
            layer.addTo(map);
          } else {
            map.removeLayer(layer);
          }
        });
      });
    }

    // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨åŠ è½½æ•°æ®
    document.addEventListener("DOMContentLoaded", () => {
      setupStyleControls();
      setupPoiControls();
      setupLayerToggles();
      if (AUTO_ENABLE) {
        autoLoadAll();
      }
    });
  </script>
</body>
</html>
